Annotations:
	Annotation methods can’t have parameters.
	Annotation methods return types are limited to primitives, String, Enums, Annotation or array of these.
	Java Annotation methods can have default values.
	Annotations can have meta annotations attached to them. Meta annotations are used to provide information about the annotation.



@Component :
	   1. It is a universal Sterotype spring Annotation.

	   2. whenever you put @Component above any class then that class will be 
	      managed by Spring IoC Container

	   3.spring will scan our application  for classes annotated with @Component.
		-Initialize them and injects any specified dependencies into them.
		-Injects them whenever needed. 

	   4.So in general , @Component is used to inject dependencies into the
		 classes(without having to write any explicit code) and use them whenever needed.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

@Repository:
		1.The @Repository Annotation is a marker of any class that fullfills the role of 
			a repository AKA Data Access Object (DAO).
			-Marker is an automatic transaltion of Exceptions
		2.@Repository job is to catch presistent-specific Exception and re-throw them 
			as one of the springs unchecked Exception.
		3.When we have a repository layer which connects to the DataBase,so to inject those all 
			repositories classes we use @Repository Annotation.



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@Controller:
		1.whenever you put @Controller above any class then that class will be 
		   mapped as the controller layer bean and register the class inside the BeanFactory.

		2.Then Bean will check for the @RequestMapping Annotation and its value .
		   Example:@RequestMapping(Value="/message")  // Localhost:8080/message
			
			-Whenever you hit the URL(Localhost:8080/message) the spring will pass the req
			  to beanFactory and come to know about the class 


		3.@Controller
		  public class PlayerController {

			@RequestMapping(value = "/message") // Localhost:8080/message
			@ResponseBody			    // Acts as a Wrapper class
			public String getMessage(){
				return "Hi , I am from controller..!"
			}
		  }

		4. Whenever you use @Controller Annotation make sure you use both
				 1.@RequestMapping(value = "/message") 	// Localhost:8080/message
				 2.@ResponseBody		        // Acts as a Wrapper class

			
						(or)
		5.If You want to get rid of @ResponseBody then make use of @RestController

			@RestController
		  	public class PlayerController {

			@RequestMapping(value = "/message") // Localhost:8080/message
			public String getMessage(){
				return "Hi , I am from controller..!"
				}
		  	}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@Service: Bussniss Logic
	1.Spring @Service annotation is used with classes that provide some business functionalities.
	 Spring context will autodetect these classes when annotation-based configuration and classpath scanning is used

	2.is used in your service layer and annotates classes that perform service tasks

	3.@Service marks a Java class that performs some service, such as executing business logic, 
	  performing calculations, and calling external APIs.

	4.This annotation is a specialized form of the @Component annotation intended
	  to be used in the service layer.

	5.The service layer is there to provide logic to operate on the data 
 	  sent to and from the DAO and the client.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@transactional:
	1.@Transactional annotation is used when you want the certain 
	 method/class(=all methods inside) to be executed in a transaction.

	2.So when you annotate a method with @Transactional , Spring dynamically creates 
	 a proxy that implements the same interface(s) as the class you're annotating 
	 And when clients make calls into your object, the calls are intercepted 
	 and the behaviors injected via the proxy mechanism




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	Annotation methods can’t have parameters.
	Annotation methods return types are limited to primitives, String, Enums, Annotation or array of these.
	Java Annotation methods can have default values.
	Annotations can have meta annotations attached to them. Meta annotations are used to provide information about the annotation.


	Java Provides five built-in annotations.

	1.@Override – When we want to override a method of Superclass, we should use this annotation to
		 inform compiler that we are overriding a method. So when superclass method is removed or
		 changed, compiler will show error message. Learn why we should always use java override 
		annotation while overriding a method.

	2.@Deprecated – when we want the compiler to know that a method is deprecated, we should use this annotation.
		 Java recommends that in javadoc, we should provide information for why this method
		 is deprecated and what is the alternative to use.

	3.@SuppressWarnings – This is just to tell compiler to ignore specific warnings they produce, for example using
		 raw types in java generics. It’s retention policy is SOURCE and it gets discarded by compiler.

	4.@FunctionalInterface – This annotation was introduced in Java 8 to indicate
		 that the interface is intended to be a functional interface.

	5.@SafeVarargs – A programmer assertion that the body of the annotated method or constructor does not 
		perform potentially unsafe operations on its varargs parameter.



		There are five types of meta annotations:

		1.@Documented – indicates that elements using this annotation should be documented 
			by javadoc and similar tools. This type should be used to annotate the declarations 
			of types whose annotations affect the use of annotated elements by their clients.
			If a type declaration is annotated with Documented, its annotations become part 
			of the public API of the annotated elements.

		2.@Target – indicates the kinds of program element to which an annotation type is applicable.
			 Some possible values are TYPE, METHOD, CONSTRUCTOR, FIELD etc. If Target meta-annotation	
			 is not present, then annotation can be used on any program element.

		3.@Inherited – indicates that an annotation type is automatically inherited.
			 If user queries the annotation type on a class declaration, and the class declaration 
			 has no annotation for this type, then the class’s superclass will automatically be
			 queried for the annotation type. This process will be repeated until an annotation
			 for this type is found, or the top of the class hierarchy (Object) is reached.

		4.@Retention – indicates how long annotations with the annotated type are to be retained.
			 It takes RetentionPolicy argument whose Possible values are SOURCE, CLASS and RUNTIME

		5.@Repeatable – used to indicate that the annotation type whose declaration it annotates is repeatable.
